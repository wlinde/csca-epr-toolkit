function [out,clean] = nlsl(nameval,params)

%%  NLSL Companion Version 1.2

%%  Before running this program, read this: 

%   (1) This program uses the params structure generated by nlslPmake.
%   You must run nlslPmake.m to generate 'params', and feed the results
%   into this program

%   (2) This program uses the following inputs:
%           name   --  The name of a tab-delimited .dat file, e.g. 'data'.
%           params --  The output of the nlslPmake script, which is user
%                      executed.
% 
%   (3) The program generates the number of .run files requested in 
%   nlslPmake.m. It then runs NLSL on each file, producing a corresponding
%   .log file.
% 
%   (4) Finally, it scrapes data from these .log files, ignoring any which
%   failed to converge or which experienced segmentation faults. 


    %% Levenberg-Mardquardt fitting convergence criteria (only for params.parType= 0, 1, or 2)

    params.NLfit={'maxit',  3000; % maximum iterations
                   'maxfun', 3000; % maximum allowed spectral calculations
                   'ftol',   1e-3;  % chi squared convergence criterion
                   'xtol',   1e-3;  % parameter convergence criterion
                   };

    %% Produce guess values and save the parameters in the local directory.
    %  If the parameters have not been run before, generate guess values and store.
    %  Check whether params have been used before -- if they have, the user
    %  wants to rerun an old seed and the same initial guesses should be
    %  used. 
    
    if isfield(params,'paramsGenerated')==0

        %  User running one fit from one point
        if and(params.parType==0,params.resType==0)
            params.trialNum=1;
        %  User running multiple fits from one point, with randomly
        %  noised data.
        elseif params.parType==0
            for ind=1:params.trialNum
                for j=1:length([params.vary{:,2}])
                    thing{j,1}=params.varyGuess{j,1};
                end
                for j=1:length([params.vary{:,2}])
                    thing{j,ind+1}=params.varyGuess{j,2};
                end
            end
            params.varyGuess=thing;
        %  User running Monte Carlo Search
        elseif params.parType==1
            for ind=1:params.trialNum
                Guesses(ind,:)=[params.vary{:,2}]+([params.vary{:,3}]-[params.vary{:,2}]).*rand(1,length([params.vary{:,2}]));
                for j=1:length([params.vary{:,2}])
                    params.varyGuess{j,ind+1}=Guesses(ind,j);
                end
            end
        %  User running Grid Search
        elseif params.parType==2
            [npoints, newTrNum]=normGrid(length([params.vary{:,2}]),params.trialNum);
            params.trialNum=newTrNum;
            for ind=1:newTrNum
                Guesses(ind,:)=[params.vary{:,2}]+([params.vary{:,3}]-[params.vary{:,2}]).*npoints(ind,:);
                for j=1:length([params.vary{:,2}])
                    params.varyGuess{j,ind+1}=Guesses(ind,j);
                end
            end
        end
            
    %  Theoretically, a user could change params.paramsGenerated to
    %  something other than 1. In that case, new parameters should still be
    %  generated
    elseif params.paramsGenerated~=1
        
        %  User running one fit from one point
        if and(params.parType==0,params.resType==0)
            params.trialNum=1;
        %  User running multiple fits from one point, with randomly
        %  noised data.
        elseif params.parType==0
            for ind=1:params.trialNum
                for j=1:length([params.vary{:,2}])
                    thing{j,1}=params.varyGuess{j,1};
                end
                for j=1:length([params.vary{:,2}])
                    thing{j,ind+1}=params.varyGuess{j,2};
                end
            end
            params.varyGuess=thing;
        %  User running Monte Carlo Search
        elseif params.parType==1
            for ind=1:params.trialNum
                Guesses(ind,:)=[params.vary{:,2}]+([params.vary{:,3}]-[params.vary{:,2}]).*rand(1,length([params.vary{:,2}]));
                for j=1:length([params.vary{:,2}])
                    params.varyGuess{j,ind+1}=Guesses(ind,j);
                end
            end
        %  User running Grid Search
        elseif params.parType==2
            [npoints, newTrNum]=normGrid(length([params.vary{:,2}]),params.trialNum);
            params.trialNum=newTrNum;
            for ind=1:newTrNum
                Guesses(ind,:)=[params.vary{:,2}]+([params.vary{:,3}]-[params.vary{:,2}]).*npoints(ind,:);
                for j=1:length([params.vary{:,2}])
                    params.varyGuess{j,ind+1}=Guesses(ind,j);
                end
            end
        end
        
    end
    
    fitvardims=size(params.vary);
    params.numFit=fitvardims(1);
    params.paramsGenerated=1;
    save('params.mat')
        

%%  Run OS-dependant system
%   This is important because the systems require different binaries. 

    if isunix==1
        [out,clean]=nlslUnix(nameval,params);
    elseif ispc==1
        [out,clean]=nlslDOS(nameval,params);
    elseif ismac==1
        [out,clean]=nlslUnix(nameval,params);
    end    
    
    % If a global optimization algorithm was used, erase irrelevant data
    rmfield(out,'intVarNames')
    rmfield(out,'intData')

end 





    
    














